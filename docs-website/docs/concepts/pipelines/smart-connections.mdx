---
title: "Smart Pipeline Connections"
id: smartpipelineconnections
slug: "/smartpipelineconnections"
description: "Learn how Haystack pipelines simplify connections through implicit joining and flexible type adaptation, reducing the need for glue components."
---

# Smart Pipeline Connections

Haystack pipelines support smarter connection semantics that reduce boilerplate and make pipeline definitions easier to read and maintain.
These features focus on simplifying how components are connected, without changing component behavior.

Smart connections help eliminate common glue components such as `Joiners` in many pipelines.

## Implicit List Joining

Pipelines natively support connecting multiple component outputs directly to a single component input, without requiring an explicit `Joiner` component.

This works when:

* All connected outputs are compatible list types.
* The target input accepts a list of the same type, for example `list[Document]`.

When multiple outputs are connected to the same input, the pipeline implicitly concatenates the lists from the outputs into a single list for the input.

### Example

Multiple converters can write directly into a single `DocumentWriter` without using a `DocumentJoiner`:

<details>

<summary>Expand to see the pipeline graph</summary>
<ClickableImage src="/img/pipeline-illustration-auto-joiner.png" alt="Pipeline architecture diagram showing a DocumentWriter receiving inputs from multiple converters without a Joiner" size="large" />

</details>

```python
from haystack import Pipeline
from haystack.components.converters import HTMLToDocument, TextFileToDocument
from haystack.components.routers import FileTypeRouter
from haystack.components.writers import DocumentWriter
from haystack.dataclasses import ByteStream
from haystack.document_stores.in_memory import InMemoryDocumentStore

sources = [
    ByteStream.from_string(text="Text file content", mime_type="text/plain"),
    ByteStream.from_string(text="<html><body>Some content</body></html>", mime_type="text/html"),
]

doc_store = InMemoryDocumentStore()

pipe = Pipeline()
pipe.add_component("router", FileTypeRouter(mime_types=["text/plain", "text/html"]))
pipe.add_component("txt_converter", TextFileToDocument())
pipe.add_component("html_converter", HTMLToDocument())
pipe.add_component("writer", DocumentWriter(doc_store))
pipe.connect("router.text/plain", "txt_converter.sources")
pipe.connect("router.text/html", "html_converter.sources")
pipe.connect("txt_converter.documents", "writer.documents")
pipe.connect("html_converter.documents", "writer.documents")

result = pipe.run({"router": {"sources": sources}})
```

This pattern is especially useful when routing files, documents, or results across multiple parallel branches.


## When You Still Need `Joiners`

Explicit `Joiners` are still useful when you need:

- Custom aggregation logic beyond simple list concatenation
- Type conversions not covered by implicit adaptation
- Explicit control over ordering

Smart connections reduce the need for glue components, but they do not remove them entirely.
When in doubt, explicit components provide clarity and more control.
