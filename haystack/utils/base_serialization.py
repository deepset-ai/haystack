# SPDX-FileCopyrightText: 2022-present deepset GmbH <info@deepset.ai>
#
# SPDX-License-Identifier: Apache-2.0

from typing import Any, Dict

from haystack.core.errors import DeserializationError, SerializationError
from haystack.core.serialization import generate_qualified_class_name, import_class_by_name


def serialize_class_instance(obj: Any) -> Dict[str, Any]:
    """
    Serializes an object that has a `to_dict` method into a dictionary.

    :param obj:
        The object to be serialized.
    :returns:
        A dictionary representation of the object.
    :raises SerializationError:
        If the object does not have a `to_dict` method.
    """
    if not hasattr(obj, "to_dict"):
        raise SerializationError(f"Object of class '{type(obj).__name__}' does not have a 'to_dict' method")

    output = obj.to_dict()
    return {"type": generate_qualified_class_name(type(obj)), "data": output}


def deserialize_class_instance(data: Dict[str, Any]) -> Any:
    """
    Deserializes an object from a dictionary representation generated by `auto_serialize_class_instance`.

    :param data:
        The dictionary to deserialize from.
    :returns:
        The deserialized object.
    :raises DeserializationError:
        If the serialization data is malformed, the class type cannot be imported, or the
        class does not have a `from_dict` method.
    """
    if "type" not in data:
        raise DeserializationError("Missing 'type' in serialization data")
    if "data" not in data:
        raise DeserializationError("Missing 'data' in serialization data")

    try:
        obj_class = import_class_by_name(data["type"])
    except ImportError as e:
        raise DeserializationError(f"Class '{data['type']}' not correctly imported") from e

    if not hasattr(obj_class, "from_dict"):
        raise DeserializationError(f"Class '{data['type']}' does not have a 'from_dict' method")

    return obj_class.from_dict(data["data"])


def serialize_value(value: Any) -> Any:
    """
    Serializes a value into a format suitable for storage or transmission.

    Handles various types including:
    - Haystack dataclass objects (Answer, Document, etc.)
    - Primitive types (returned as is)
    - Lists of primitives (returned as is)
    - Lists of complex types (recursively serialized)
    - Dictionaries (recursively serialized)

    :param value: The value to serialize
    :returns: The serialized representation of the value
    """

    if hasattr(value, "to_dict") and callable(getattr(value, "to_dict")):
        serialized_value = value.to_dict()
        serialized_value["_type"] = generate_qualified_class_name(type(value))

        return serialized_value

    # this is a hack to serialize inputs that don't have a to_dict
    elif hasattr(value, "__dict__"):
        return {"_type": value.__class__, "attributes": value.__dict__}

    # recursively serialize all inputs in a dict
    elif isinstance(value, dict):
        return {k: serialize_value(v) for k, v in value.items()}

    # recursively serialize all inputs in lists or tuples
    elif isinstance(value, list):
        return [serialize_value(item) for item in value]

    return value


# pylint: disable=too-many-return-statements
def deserialize_value(value: Any) -> Any:
    """
    Deserializes a value from its serialized representation.

    Handles various types including:
    - Haystack dataclass objects (Answer, Document, etc.)
    - Primitive types (returned as is)
    - Lists of primitives (returned as is)
    - Lists of complex types (recursively deserialized)
    - Dictionaries (recursively deserialized)

    :param value: The serialized value to deserialize
    :returns: The deserialized value
    """

    # None or primitive types are returned as is
    if not value or isinstance(value, (str, int, float, bool)):
        return value

    # list of primitive types are returned as is
    if isinstance(value, list) and all(isinstance(i, (str, int, float, bool)) for i in value):
        return value

    if isinstance(value, list):
        # list of lists are called recursively
        if all(isinstance(i, list) for i in value):
            return [deserialize_value(i) for i in value]
        # list of dicts are called recursively
        if all(isinstance(i, dict) for i in value):
            return [deserialize_value(i) for i in value]

    # check if the dictionary has a "_type" key and the class type has a "from_dict" method
    if isinstance(value, dict):
        if "_type" in value:
            obj_class = import_class_by_name(value.pop("_type"))
            if hasattr(obj_class, "from_dict"):
                return obj_class.from_dict(value)

        # If not a known type, recursively deserialize each item in the dictionary
        return {k: deserialize_value(v) for k, v in value.items()}

    return value
