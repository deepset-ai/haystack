# SPDX-FileCopyrightText: 2022-present deepset GmbH <info@deepset.ai>
#
# SPDX-License-Identifier: Apache-2.0

from typing import Any, Dict

from haystack.core.errors import DeserializationError, SerializationError
from haystack.core.serialization import generate_qualified_class_name, import_class_by_name


def serialize_class_instance(obj: Any) -> Dict[str, Any]:
    """
    Serializes an object that has a `to_dict` method into a dictionary.

    :param obj:
        The object to be serialized.
    :returns:
        A dictionary representation of the object.
    :raises SerializationError:
        If the object does not have a `to_dict` method.
    """
    if not hasattr(obj, "to_dict"):
        raise SerializationError(f"Object of class '{type(obj).__name__}' does not have a 'to_dict' method")

    output = obj.to_dict()
    return {"type": generate_qualified_class_name(type(obj)), "data": output}


def deserialize_class_instance(data: Dict[str, Any]) -> Any:
    """
    Deserializes an object from a dictionary representation generated by `auto_serialize_class_instance`.

    :param data:
        The dictionary to deserialize from.
    :returns:
        The deserialized object.
    :raises DeserializationError:
        If the serialization data is malformed, the class type cannot be imported, or the
        class does not have a `from_dict` method.
    """
    if "type" not in data:
        raise DeserializationError("Missing 'type' in serialization data")
    if "data" not in data:
        raise DeserializationError("Missing 'data' in serialization data")

    try:
        obj_class = import_class_by_name(data["type"])
    except ImportError as e:
        raise DeserializationError(f"Class '{data['type']}' not correctly imported") from e

    if not hasattr(obj_class, "from_dict"):
        raise DeserializationError(f"Class '{data['type']}' does not have a 'from_dict' method")

    return obj_class.from_dict(data["data"])


def serialize_value(value: Any) -> Any:
    """
    Serializes a value into a format suitable for storage or transmission.

    Handles various types including:
    - Haystack dataclass objects (Answer, Document, etc.)
    - Primitive types (returned as is)
    - Lists of primitives (returned as is)
    - Lists of complex types (recursively serialized)
    - Dictionaries (recursively serialized)

    :param value: The value to serialize
    :returns: The serialized representation of the value
    """
    if hasattr(value, "to_dict") and callable(value.to_dict):
        serialized_value = value.to_dict()
        serialized_value["_type"] = generate_qualified_class_name(type(value))
        return serialized_value

    # this is a hack to serialize inputs that don't have a to_dict
    elif hasattr(value, "__dict__"):
        return {
            "_type": generate_qualified_class_name(type(value)),
            "attributes": {k: serialize_value(v) for k, v in value.__dict__.items()},
        }

    # recursively serialize all inputs in a dict
    elif isinstance(value, dict):
        return {k: serialize_value(v) for k, v in value.items()}

    # recursively serialize all inputs in lists or tuples
    elif isinstance(value, (list, tuple, set)):
        return type(value)(serialize_value(v) for v in value)

    # None and primitives fall through
    return value


def deserialize_value(value: Any) -> Any:
    """
    Deserializes a value from its serialized representation.

    - Primitives and None are returned as-is.
    - dicts with a "_type" key are turned back into instances:
        * If the target class has a `from_dict`, it's used.
        * Otherwise, if an "attributes" sub-dict exists, we reconstruct
          by creating a blank instance and setting attributes.
    - Other dicts, lists, tuples, and sets are recursively deserialized.

    :param value: The serialized value to deserialize
    :returns: The deserialized value
    """
    # 1) Primitives & None
    if value is None or isinstance(value, (str, int, float, bool)):
        return value

    # 2) Typed objects
    if isinstance(value, dict) and "_type" in value:
        type_name = value.pop("_type")  # remove without mutating original
        obj_class = import_class_by_name(type_name)

        # a) Preferred: class method
        if hasattr(obj_class, "from_dict") and callable(obj_class.from_dict):
            deserialized_payload = {k: deserialize_value(v) for k, v in value.items()}
            return obj_class.from_dict(deserialized_payload)

        # b) Fallback: if attributes are present, we reconstruct the object
        if "attributes" in value:
            raw_attrs = value["attributes"]
            deserialized_attrs = {k: deserialize_value(v) for k, v in raw_attrs.items()}
            instance = obj_class.__new__(obj_class)
            for attr_name, attr_value in deserialized_attrs.items():
                setattr(instance, attr_name, attr_value)
            return instance

    # 3) Generic dict
    if isinstance(value, dict):
        return {k: deserialize_value(v) for k, v in value.items()}

    # 4) Collections
    if isinstance(value, (list, tuple, set)):
        return type(value)(deserialize_value(v) for v in value)

    # 5) Anything else
    return value
